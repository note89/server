{"title":"Frontend | Implementing Real-Time Browser Notifications in Gotify","id":"zlz9PX7vZ5o6rfKWmS5o8WKmTJVPC91gJtTXX4RScwU=","steps":[{"type":"textOnly","description":"Welcome to the tour of browser notifications in Gotify! In this tour, we'll explore how browser notifications are implemented in the Gotify project. We'll look at both the frontend (TypeScript/React) and backend (Go) components that work together to deliver real-time notifications to users. Let's get started!","title":"","id":"698"},{"type":"highlight","description":"Let's begin by examining the core functions for browser notifications in the `browserNotification.ts` file. This file contains three main functions: `mayAllowPermission`, `requestPermission`, and `notifyNewMessage`. These functions handle permission checking, requesting notification permissions, and creating notifications, respectively.","file":"ui/src/snack/browserNotification.ts","highlight":[{"start":5,"end":27}],"title":"","id":"699"},{"type":"highlight","description":"The `notifyNewMessage` function is responsible for creating and displaying browser notifications. It uses the `notifyjs` library for cross-browser compatibility. Notice how it sets up click and show handlers for the notification.","file":"ui/src/snack/browserNotification.ts","highlight":[{"start":18,"end":44}],"title":"","id":"700"},{"type":"highlight","description":"The `WebSocketStore` class manages the WebSocket connection for real-time updates. Let's focus on how it establishes the connection. The `listen` method is responsible for setting up the WebSocket connection using the user's authentication token.","file":"ui/src/message/WebSocketStore.ts","highlight":[{"start":7,"end":24}],"title":"","id":"710"},{"type":"highlight","description":"Once the WebSocket connection is established, the `WebSocketStore` sets up event handlers for various scenarios. The `onmessage` handler processes incoming messages, while the `onclose` handler manages reconnection attempts if the connection is lost.","file":"ui/src/message/WebSocketStore.ts","highlight":[{"start":25,"end":51}],"title":"","id":"711"},{"type":"highlight","description":"The `MessagesStore` class is responsible for managing the state of messages in the application. It handles loading messages, publishing new messages, and removing messages. Pay attention to the `publishSingleMessage` method, which is called when a new message is received via WebSocket.","file":"ui/src/message/MessagesStore.ts","highlight":[{"start":18,"end":70}],"title":"","id":"702"},{"type":"highlight","description":"The `registerReactions` function in `reactions.ts` sets up the event handlers for new messages. When a new message is received via WebSocket, it's published to the MessagesStore and a browser notification is created. Note how it also handles high-priority messages by playing an audio alert.","file":"ui/src/reactions.ts","highlight":[{"start":13,"end":35}],"title":"","id":"703"},{"type":"highlight","description":"The `IMessage` interface defines the structure of a message in Gotify. This TypeScript interface is crucial for frontend development, ensuring type safety and consistency when handling messages throughout React components.\n\nFor example, in the `notifyNewMessage` function we saw earlier, the `msg` parameter is of type `IMessage`. This typing ensures that all required fields are present when creating a browser notification.\n\nIn React components, you'll often see props or state variables typed as `IMessage`, allowing for autocomplete and catching potential errors at compile-time. This interface is particularly important when working with WebSocket data and displaying messages in the UI.","file":"ui/src/types.ts","highlight":[{"start":31,"end":40}],"title":"","id":"704"},{"type":"highlight","description":"The `Navigation` component implements the 'Enable Notifications' button, a crucial frontend element in Gotify's notification system. This button appears when notifications aren't enabled, allowing users to grant permission easily.\n\nLet's break down its implementation:\n1. The button's visibility is controlled by the `showRequestNotification` state.\n2. When clicked, it calls the `requestPermission()` function we saw earlier in `browserNotification.ts`.\n3. After requesting permission, it updates the state to hide the button.\n\nThis component bridges the gap between the user interface and the notification permission system, ensuring a smooth user experience for enabling real-time notifications.","file":"ui/src/layout/Navigation.tsx","highlight":[{"start":105,"end":115}],"title":"","id":"705"},{"type":"highlight","description":"On the backend, the `Notify` function in the `API` struct is responsible for sending messages to connected WebSocket clients. This function is called whenever a new message needs to be sent to a user.","file":"api/stream/stream.go","highlight":[{"start":83,"end":91}],"title":"","id":"706"},{"type":"textOnly","description":"Let's put our knowledge into practice! To test the notification system:\n\n1. Open the Gotify web interface in your browser.\n2. Ensure you're logged in and have granted notification permissions.\n3. Use the Gotify API or CLI to send a test message to your user.\n4. Observe the real-time update in the web interface and the browser notification.\n\nThis test allows you to see the entire notification flow in action, from the backend \nsending a message to the frontend receiving and displaying it. It's a great way to \nunderstand how all the components we've explored work together in a real-world scenario.\n\nRemember, as a frontend developer, you can use this method to test your notification \nhandling code and ensure a smooth user experience.","title":"","id":"707"}]}