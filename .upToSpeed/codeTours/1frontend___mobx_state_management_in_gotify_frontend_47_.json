{"title":"Frontend | MobX State Management in Gotify Frontend","id":"Hda5yeb+n+zez8ycnfE/BHskXcN/zGXYRtOWalgcfhc=","steps":[{"type":"textOnly","description":"Welcome to our tour on state management in the Gotify frontend! In this tour, we'll explore how the application manages its state using MobX, a powerful state management library. We'll look at the core concepts, key components, and how they work together to create a robust and reactive user interface.","title":"","id":"724"},{"type":"highlight","description":"Let's examine the StoreMapping interface, which defines all the stores available in the application. This interface is crucial for state management in Gotify's frontend, similar to how you might use Redux or React Context in a typical React application.\n\nEach property in this interface represents a specific store:\n- userStore: Manages user-related data and operations\n- snackManager: Handles notifications and toasts\n- messagesStore: Deals with message data and operations\n- currentUser: Maintains the current user's state\n- clientStore: Manages client-related information\n- appStore: Handles application data and operations\n- pluginStore: Manages plugin-related state\n- wsStore: Handles WebSocket connections for real-time updates\n\nThese stores work together to create a comprehensive state management system, allowing different components to access and modify relevant parts of the application state efficiently.","file":"ui/src/inject.tsx","highlight":[{"start":12,"end":21}],"title":"","id":"725"},{"type":"highlight","description":"Let's examine the BaseStore class, focusing on MobX decorators. These decorators are key to efficient state management in React applications:\n\n@observable: This decorator marks the 'items' array as observable, allowing MobX to track changes.\n\n@action: Decorates methods that modify state, like 'remove', 'refresh', and 'clear'. Actions help in organizing state mutations.\n\nThese decorators enable automatic updates in React components when state changes, a core feature of MobX.","file":"ui/src/common/BaseStore.ts","highlight":[{"start":14,"end":50}],"title":"","id":"726"},{"type":"highlight","description":"Let's examine the AppStore, a concrete implementation of BaseStore. This store manages application-related data and operations:\n\n1. It extends BaseStore<IApplication>, inheriting generic CRUD operations.\n2. It implements specific methods like requestItems() and requestDelete().\n3. It adds custom methods such as uploadImage(), update(), and create().\n4. It uses MobX's @action decorator for state-modifying methods.\n5. It interacts with the backend API using axios for data operations.\n6. It utilizes a SnackReporter for user notifications.\n\nThis implementation showcases how Gotify extends the generic BaseStore to handle application-specific data and operations.","file":"ui/src/application/AppStore.ts","highlight":[{"start":8,"end":72}],"title":"","id":"727"},{"type":"highlight","description":"Let's see how these stores are initialized and provided to the React component tree. The initStores function creates instances of all the stores and combines them into a single object.","file":"ui/src/index.tsx","highlight":[{"start":29,"end":50}],"title":"","id":"728"},{"type":"highlight","description":"Components can access these stores using the inject function. This custom implementation wraps MobX's inject to provide type-safe store injection for React components.","file":"ui/src/inject.tsx","highlight":[{"start":26,"end":33}],"title":"","id":"729"},{"type":"highlight","description":"Let's look at a practical example of how a component uses injected stores. The Messages component injects the messagesStore and appStore to manage and display messages.","file":"ui/src/message/Messages.tsx","highlight":[{"start":22,"end":23}],"title":"","id":"730"},{"type":"highlight","description":"Let's start by examining the MessagesStore, a key component in managing message data for the Gotify frontend. This store handles fetching, storing, and manipulating messages for different applications.","file":"ui/src/message/MessagesStore.ts","highlight":[{"start":18,"end":29}],"title":"","id":"741"},{"type":"highlight","description":"The MessagesStore uses a private state object to manage message states for different applications. Each application has its own MessagesState, which includes an array of messages, pagination information, and loading status.","file":"ui/src/message/MessagesStore.ts","highlight":[{"start":19,"end":36}],"title":"","id":"742"},{"type":"highlight","description":"The loadMore method is responsible for fetching and updating messages for a specific application. It handles pagination and updates the state accordingly.","file":"ui/src/message/MessagesStore.ts","highlight":[{"start":42,"end":60}],"title":"","id":"743"},{"type":"highlight","description":"The MessagesStore provides methods for publishing new messages and removing messages. The publishSingleMessage method adds a new message to the appropriate application's state, while removeByApp and removeSingle handle message deletion.","file":"ui/src/message/MessagesStore.ts","highlight":[{"start":62,"end":97}],"title":"","id":"744"},{"type":"highlight","description":"The MessagesStore includes methods for clearing all messages and refreshing messages for a specific application. These operations are crucial for maintaining an accurate and up-to-date view of the messages.","file":"ui/src/message/MessagesStore.ts","highlight":[{"start":99,"end":109}],"title":"","id":"745"},{"type":"highlight","description":"The MessagesStore implements caching and transformation of messages using MobX's createTransformer. This optimizes performance by memoizing the results of message transformations.","file":"ui/src/message/MessagesStore.ts","highlight":[{"start":139,"end":165}],"title":"","id":"746"},{"type":"highlight","description":"The WebSocketStore is crucial for real-time updates in Gotify. It establishes a WebSocket connection and interacts with other stores to keep the application state current.\n\nKey points:\n1. It listens for new messages and passes them to the MessagesStore.\n2. It works with CurrentUser for authentication.\n3. It triggers Notifications for new messages.\n4. Its 'listen' method is called in reactions.ts when a user logs in.\n\nThis real-time interaction ensures that the UI always reflects the latest state, a core principle of effective state management in reactive applications.","file":"ui/src/message/WebSocketStore.ts","highlight":[{"start":7,"end":51}],"title":"","id":"732"},{"type":"highlight","description":"Reactions play a vital role in responding to state changes. The registerReactions function sets up reactions to handle user login state and connection errors.","file":"ui/src/reactions.ts","highlight":[{"start":5,"end":46}],"title":"","id":"733"},{"type":"textOnly","description":"We've now explored the key aspects of state management in the Gotify frontend. We've seen how MobX is used to create reactive stores, how these stores are injected into components, and how real-time updates and reactions are handled. This architecture allows for efficient state management and a responsive user interface, crucial for a messaging application like Gotify.","title":"","id":"734"}]}